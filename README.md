# 要約

## CHAPTER 1 小さくまとめてわかりやすくする

### プログラムの変更が楽になる書き方

* わかりやすい名前を使う
* 長いメソッドは段落に分けて読みやすくする
* 目的ごとに変数を用意する(1つの変数を使いまわして代入、つまり破壊的代入をしないこと)
* メソッドの抽出
* 異なるクラスの重複したコードをなくす
  * ⼿順1 それぞれのクラスで該当するコード部分（段落）を、メソッ
    ドに抽出する
    ⼿順2 2つのクラスに参照関係がある場合：参照する側で抽出した
    メソッド呼び出しを、参照先のオブジェクトのメソッドの呼
    び出しに書き換える
    ⼿順2' 2つのクラスに参照関係がない場合：共通のメソッドの置き
    場所として、別のクラスを新たに作成し、元のクラスで抽出
    したメソッドを移動する
    ⼿順3 元の2つのクラスのメソッド呼び出しを、それぞれ新しいク
    ラスの共通メソッドを利⽤するように書き換える
* 狭い関心ごとに特化したクラスにする(業務の関心ごとに対応したクラスを作成する)


「送料」クラスのように、業務で使われる用語に合わせて、
その用語の関心事に対応するクラスををドメインオブジェクトと呼びます。
アプリケーションの対象領域(ドメイン)の関心事を記述したオブジェクトという意味です。

### 値を扱うための専用クラスを作る

値の種類ごとに専用の型を用意するとコードが安定し、
コードの意図が明確になります。
値を扱うためのクラスを作るやり方を値オブジェクトと呼びます。

### 値オブジェクトは不変にする

値オブジェクトを不変にする方法は次の通り

* インスタンス変数はコンストラクタでオブジェクトの生成時に設定する
* インスタンス変数を変更するメソッド(setterメソッド)を作らない
* 別の値が必要であれば、別のインスタンス(オブジェクト)を作る

このような設計のやり方を完全コンストラクタと呼びます

### 型を使ってコードをわかりやすく安全にする

値オブジェクトを使うことによって、引数の渡し間違いを防ぐことができる。


### コレクション型を扱うコードの整理

#### コレクション型を扱うロジックを専用クラスに閉じ込める

例えば、顧客を扱うクラスCustomerを作成した場合、顧客一覧は
List<Customer>で表現できるが、それも専用クラスとして作成する。

```java
class Customers {
    List<Customer> customers;
    
    void add(Customer customer) { ... }
    
    void removeIfExist(Customer customer) { ... }
    
    int count() { ... }
    
    Customers importantCustomers() { ... }
}
```

このように、全てのロジックをCustomersクラスに閉じ込めておけば、
ロジックを変更する時の影響をCustomersクラスに閉じ込めやすくなります。

なお、Customersクラスでは、List<Customer>以外のインスタンス変数を持たないようにします。

このように、コレクションを一つだけ持つ専用クラスを作るやり方をコレクションオブジェクト
あるいはファーストクラスコレクションと呼びます。

### コレクションの状態を安定させる

下記のような実装は悪い例。
外部で、要素の追加や削除ができてしまうため。
```java
class Customers {
    List<Customer> customers;
    
    List<Customer> getList() {
    return customers;
    }
}
```
コレクションの操作を安定させる方法は３つある。

・コレクション操作のロジックをコレクションオブジェクトに移動す
る
・コレクション操作の結果も同じ型のコレクションオブジェクトとし
て返す
・コレクションを「不変」にして外部に渡す

良い例
```java
class Customers {
    List<Customer> customers;
    
    Customers add(Customer customer) {
    List<Customer> result = new ArrayList<>(customers);
    return new Customers(result.add(customer));
    }
}
```

## CHAPTER 2 場合分けのロジックを整理する

if文やswitch文が増えてくると可読性が悪くなる、、どう解決すれば良い？

### 判断や処理のロジックをメソッドに独立させる

```java
// 悪い例
if(customerType.equals("child")) {
  fee = baseFee * 0.5 ;
}

// 良い例
if(isChild()) {
  fee = childFee();
}
// 判断ロジックの詳細
private Boolean isChild() {
    return customerType.equals("child");
}
// 計算ロジックの詳細
private int childFee() {
    return baseFee * 0.5 ;
}

```

### else句をなくすと条件分岐が単純になる

else句がなくした書き方

```java
Yen fee(){
  if(isChild()) return childFee();
  if(isSenior()) return seniorFee();
  return adultFee();
}
```
else句を使わずに早期リターンするこの書き方をガード節と呼びます。

### 区分ごとのロジックを別クラスに分ける

例えば、顧客の区分ごとに料金計算が異なる場合、
顧客区分ごとに大人クラス、子供クラス、シニアクラスを作り、
区分ごとの名称と料金計算のロジックを分けて記述します。

区分ごとにクラスを使う場合、それぞれの型を意識して使わなくても済むように
するには、インターフェースを使って、異なる型を同じ型として扱うことができる。

インターフェース宣言と、区分ごとの専用クラスを組み合わせて、
区分ごとに異なるクラスのオブジェクトを同じ型として扱う仕組みを多態と呼びます。

### 区分ごとのクラスのインスタンスを生成する

区分ごとのクラスのインスタンスを生成する時には、
if文で場合わけが必要になりそうですが、ここではmapを利用することで
if文を不要とすることが可能です。

```java
class FeeFactory {
  static Map<String,Fee> types;

  static
  {
  types.put( "adult", new AdultFee());
  types.put( "child", new ChildFee() );
  }
  static Fee feeByName(String name) {
      return types.get(name);
  }
}
```

料金区分の名前をキーとしてオブジェクトを生成しておき、
mapとして保持しておけば、料金区分名でオブジェクトを取得できます。

### 列挙型を使えばもっとかんたん

多態には、区分の一覧がわかりにくいという問題があります。
列挙型を使えば、一覧を明示的に記述できます。

(パッケージchpter2のコードを参照)

### 状態遷移をわかりやすく記述する

状態遷移を列挙型とコレクションを使って表現する方法は以下となります。

* ある状態から遷移可能な状態(複数)をSetで宣言する
* 遷移元の状態をキーに、遷移可能な状態のSetをバリューにしたMapを宣言する

参考となるコードは、capter2.state配下に記載。

このようなコードを書くことで、

* あるイベントがその状態で起きて良いイベントか起きてはいけないイベントかの判定
* ある状態で発生しても良いイベントの一覧の表示

が可能になります。


